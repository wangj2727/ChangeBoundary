times_planned()
times_planned
times_planned<-as.numeric(unlist(str_split(planned_times, ",")))
times_actual <- as.numeric(unlist(str_split(actual_toNow, ",")))
newfutimes<-as.numeric(unlist(str_split(newfutimes, ",")))
as.numeric(unlist(str_split(planned_times, ",")))
planned_times <- "0.5,1"
actual_toNow <- "0.5"
newfutimes <- "0.75, 1"
times_planned<-as.numeric(unlist(str_split(planned_times, ",")))
times_actual <- as.numeric(unlist(str_split(actual_toNow, ",")))
newfutimes<-as.numeric(unlist(str_split(newfutimes, ",")))
times_planned
times_actual
newfutimes
times <- c(times_actual, times_planned[times_planned>times_actual])
times_update <- c(times_actual, newfutimes[newfutimes>times_actual])
tadapt<- times_actual[length(times_actual)]
times
times_update
tadapt
boundary<-ldBounds(t=times,iuse=selectedIuse, alpha=alpha, sides = 1, phi = selectedPhi)$upper.bounds
boundary<-ldBounds(t=times,iuse=1, alpha=0.025, sides = 1, phi = 1)$upper.bounds
boundary
futimes<-times_planned[times_planned>tadapt] # future times, orig.
fubounds<-boundary[times_planned>tadapt] # orig future bound.
futimes
fubounds
theta<-0 # use null to compute CRP (cond. rej. prob.)
CRP<-crossprob(theta,tadapt,z,futimes,fubounds)
CRP
u1u2<-(newfutimes-tadapt)/(1-tadapt)
u1u2
#actual_toNow <- "0.5"
actual_toNow <- "0.25,0.5"
times_planned<-as.numeric(unlist(str_split(planned_times, ",")))
times_actual <- as.numeric(unlist(str_split(actual_toNow, ",")))
newfutimes<-as.numeric(unlist(str_split(newfutimes, ",")))
times <- c(times_actual, times_planned[times_planned>times_actual])   #### old times
times_update <- c(times_actual, newfutimes[newfutimes>times_actual])  #### new times
tadapt<- times_actual[length(times_actual)]
boundary<-ldBounds(t=times,iuse=1, alpha=0.025, sides = 1, phi = 1)$upper.bounds
times
times_update
times_planned
times <- unique(c(times_actual, times_planned[times_planned>times_actual]))   #### old times
times_update <- c(times_actual, newfutimes[newfutimes>times_actual])  #### new times
tadapt<- times_actual[length(times_actual)]
times
times_update
tadapt
boundary<-ldBounds(t=times,iuse=1, alpha=0.025, sides = 1, phi = 1)$upper.bounds
boundary
futimes<-times_planned[times_planned>tadapt] # future times, orig.
fubounds<-boundary[times_planned>tadapt] # orig future bound.
theta<-0 # use null to compute CRP (cond. rej. prob.)
CRP<-crossprob(theta,tadapt,z,futimes,fubounds)
# Now consider the new schedule of future look times
u1u2<-(newfutimes-tadapt)/(1-tadapt)
CRP
u1u2
actual_toNow <- "0.5"
times_planned<-as.numeric(unlist(str_split(planned_times, ",")))
times_actual <- as.numeric(unlist(str_split(actual_toNow, ",")))
newfutimes<-as.numeric(unlist(str_split(newfutimes, ",")))
times <- unique(c(times_actual, times_planned[times_planned>times_actual]))   #### old times
times_update <- c(times_actual, newfutimes[newfutimes>times_actual])  #### new times
tadapt<- times_actual[length(times_actual)]
boundary<-ldBounds(t=times,iuse=1, alpha=0.025, sides = 1, phi = 1)$upper.bounds
futimes<-times_planned[times_planned>tadapt] # future times, orig.
fubounds<-boundary[times_planned>tadapt] # orig future bound.
theta<-0 # use null to compute CRP (cond. rej. prob.)
CRP<-crossprob(theta,tadapt,z,futimes,fubounds)
# Now consider the new schedule of future look times
u1u2<-(newfutimes-tadapt)/(1-tadapt)
CRP
z
futimes
fubounds
tadapt
actual_toNow <- "0.25,0.5"
times_planned<-as.numeric(unlist(str_split(planned_times, ",")))
times_actual <- as.numeric(unlist(str_split(actual_toNow, ",")))
newfutimes<-as.numeric(unlist(str_split(newfutimes, ",")))
times <- unique(c(times_actual, times_planned[times_planned>times_actual]))   #### old times
times_update <- c(times_actual, newfutimes[newfutimes>times_actual])  #### new times
tadapt<- times_actual[length(times_actual)]
boundary<-ldBounds(t=times,iuse=1, alpha=0.025, sides = 1, phi = 1)$upper.bounds
futimes<-times_planned[times_planned>tadapt] # future times, orig.
fubounds<-boundary[times_planned>tadapt] # orig future bound.
theta<-0 # use null to compute CRP (cond. rej. prob.)
CRP<-crossprob(theta,tadapt,z,futimes,fubounds)
# Now consider the new schedule of future look times
u1u2<-(newfutimes-tadapt)/(1-tadapt)
CRP
theta
tadapt
z
futimes
fubounds
boundary
boundary[times_planned>tadapt]
times_planned
runApp('h:/My Documents/GitHub/ChangeBoundary/app_v1.R')
runApp('h:/My Documents/GitHub/ChangeBoundary/app_v2.R')
runApp('h:/My Documents/GitHub/ChangeBoundary/app_v2.R')
crossprob<-function(theta,tadapt,z,futimes,fubounds){
# computes the conditional crossing probabilities by
# futimes, given Z(tadapt)=z
# theta is drift parameter
# tadapt is time after which we adapt
# z=Z(tadapt)
# futimes is vector of future times
# fubounds is vector of future boundaries
numfu<-length(futimes) # number of future times
dvec<-(fubounds*sqrt(futimes)-z*sqrt(tadapt) -theta*(futimes-tadapt))/sqrt(futimes-tadapt)
uvec<-(futimes-tadapt)/(1-tadapt)
crossingprob<-ldPower(za=rep(-8,numfu),zb=dvec,t=uvec,drift=0)$cum.exit  # conditional probability
# of crossing by times futimes, given Z(tadapt)=z
return(crossingprob)
}
# a function using Simpsonâ€™s rule to perform integration written by Mike P.
simpson<-function(f,dx){
# Approximates integrals using Simpson's rule.
# f is a vector of function values at 2m+1 equally-spaced x values (comprising 2m intervals of length dx)
m<-(length(f)-1)/2
evens<-2*(1:m); odds<-2*(1:m)+1; last<-2*m+1
int<-(4*sum(f[evens])+2*sum(f[odds])+f[1]-f[last])*(dx/3)
return(int)
}
library(ldbounds)
library(tidyverse)
# scenario #2
planned_times <- "1"
actual_toNow <- "0.25,0.5"
newfutimes <- "0.65, 0.75, 1"
### ====
times_planned<-as.numeric(unlist(str_split(planned_times, ",")))
times_actual <- as.numeric(unlist(str_split(actual_toNow, ",")))
newfutimes<-as.numeric(unlist(str_split(newfutimes, ",")))
times <- unique(c(times_actual, times_planned[times_planned>max(times_actual)]))   #### old times
times_update <- c(times_actual, newfutimes[newfutimes>max(times_actual)])  #### new times
tadapt<- times_actual[length(times_actual)]
boundary<-ldBounds(t=times,iuse=1, alpha=0.025, sides = 1, phi = 1)$upper.bounds
futimes<-times_planned
fubounds <- boundary[unlist(lapply(times_planned, function(x){which(times==x)}))]
#fubounds<-boundary[which(times==times_planned)]
# futimes<-times[times>tadapt] # future times, orig.
# fubounds<-boundary[times>tadapt] # orig future bound.
z<-2.5
theta<-0 # use null to compute CRP (cond. rej. prob.)
CRP<-crossprob(theta,tadapt,z,futimes,fubounds)
# Now consider the new schedule of future look times
u1u2<-(newfutimes-tadapt)/(1-tadapt)
# calculate upper bounds given original alpha level, actual schedule up to now + new future schedules after adaptation time, and pre-specified spending function
zb_est <- ldBounds(t=times_update, iuse=3, alpha=0.025, sides = 1, phi = 1.5)$upper.bounds
# calculate original hypothesized treatment effect if the corresponding check box was selected by the users
theta_orig<-ldPower(za=rep(-8,length(times_update)),zb=zb_est,t=times_update,pow=0.9, drift=NULL)$drift
L <- (z - 5) /sqrt(tadapt)  # lower limits of the integral
U <- (z+ 5) /sqrt(tadapt)  # upper limits of the integral
# create equally-spaced values between L and U
intervalNum <- 50
dx <- (U-L)/50  ### increment
inbetween <- seq(L, U, by=dx)
for(i in 1:30){
d1d2<-ldBounds(t=u1u2,iuse=3,phi=0.1*i, alpha=CRP[length(CRP)], sides=1)$upper.bounds
# power spending function with power parameter phi.  Generates new boundary d1,d2 yielding the given CRP
c1c2<-(d1d2*sqrt(newfutimes-tadapt)+z*sqrt(tadapt))/sqrt(newfutimes) # revised Z(t) boundaries for future looks that yield the given CRP
# Compute conditional power under current trend
theta<-z/sqrt(tadapt)
cptheta<-crossprob(theta,tadapt,z,newfutimes,c1c2)
# Compute conditional power under current trend
theta<-z/sqrt(tadapt)
cptheta<-crossprob(theta,tadapt,z,newfutimes,c1c2)
newrow<-c(.1*i,c1c2,cptheta)
#####
# compute predictive power
pp<-NULL
for(f in inbetween){
pp<-rbind(pp,crossprob(f,tadapt,z,newfutimes,c1c2))
}
y<- -(tadapt/2)*(inbetween-z/sqrt(tadapt))^2
f<-sqrt(tadapt/(2*pi))*pp*exp(y)
simpOut<-NULL
for(ff in 1:ncol(f)){
simpOut <- c(simpOut,simpson(f[,ff], dx))
}
######
newrow <- c(newrow,simpOut)
infomat<-rbind(infomat,newrow)
infomat<-rbind(infomat,newrow)
}
infomat<-c()
for(i in 1:30){
d1d2<-ldBounds(t=u1u2,iuse=3,phi=0.1*i, alpha=CRP[length(CRP)], sides=1)$upper.bounds
# power spending function with power parameter phi.  Generates new boundary d1,d2 yielding the given CRP
c1c2<-(d1d2*sqrt(newfutimes-tadapt)+z*sqrt(tadapt))/sqrt(newfutimes) # revised Z(t) boundaries for future looks that yield the given CRP
# Compute conditional power under current trend
theta<-z/sqrt(tadapt)
cptheta<-crossprob(theta,tadapt,z,newfutimes,c1c2)
# Compute conditional power under current trend
theta<-z/sqrt(tadapt)
cptheta<-crossprob(theta,tadapt,z,newfutimes,c1c2)
newrow<-c(.1*i,c1c2,cptheta)
#####
# compute predictive power
pp<-NULL
for(f in inbetween){
pp<-rbind(pp,crossprob(f,tadapt,z,newfutimes,c1c2))
